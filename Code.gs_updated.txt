/**
 * @OnlyCurrentDoc
 */

/* ==================== 빌드/일반 설정 ==================== */
const BUILD_VERSION = '2025-02-13+FINAL-FIXED-COMPATIBLE';
const MAX_WIDTH_MM  = 600;
const MAX_LENGTH_MM = 1800;
const SHIPPING_MODE = 'per-order'; // 'per-order' | 'per-unit'
const CACHE_TTL_SEC = 60 * 30;

/* ==================== 스프레드시트 설정 ==================== */
const PRICE_SHEET_ID   = '1HSo0_5e5rbxFUGXVAavXZoDpzKKEVercB1Nd52GXGLw';
const PRICE_SHEET_NAME = '단가표';
const ORDER_SHEET_ID   = '1J9Q2UybMsx6Kv_V7q2LXt1pbewtUF7TRQWcBymOrS9A';
const ORDER_SHEET_NAME = '견적요청';

/* ==================== SOLAPI(카카오 알림톡/LMS) 설정 ==================== */
const SOLAPI_API_KEY    = 'NCSTLNWD19QCQIDK';
const SOLAPI_API_SECRET = '9ZMXYDBKJGMTYCF2MTDXGE2DUZTZ0SHY';
const SENDER_PHONE      = '01029488203';
const KAKAO_PF_ID       = 'KA01PF250717222607219jkItrsz0ptP';
const TEMPLATE_ID       = 'KA01TP250916040322542jg37R2XFpbe';
const LMS_SUBJECT       = '주문 안내';

/* ==================== OpenAI 설정 ==================== */
const OPENAI_API_KEY_TEMP = ''; 

function getOpenAiApiKey(){
  const k=PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY');
  if(k&&k.startsWith('sk-')) return k;
  if(OPENAI_API_KEY_TEMP&&OPENAI_API_KEY_TEMP.startsWith('sk-')) return OPENAI_API_KEY_TEMP;
  throw new Error('OpenAI 키 없음: setOpenAIKey()로 OPENAI_API_KEY 저장 필요');
}
function setOpenAIKey(){ const KEY='sk-REPLACE_WITH_REAL_KEY'; PropertiesService.getScriptProperties().setProperty('OPENAI_API_KEY',KEY); }

/* ==================== 유틸리티 ==================== */
function L(rid, ...args){ Logger.log(`[RID ${rid}] ` + args.map(a => typeof a==='object'?JSON.stringify(a):String(a)).join(' ')); }
function jsonOut(o){ return ContentService.createTextOutput(JSON.stringify(o||{})).setMimeType(ContentService.MimeType.JSON); }
function jsOut(s){ return ContentService.createTextOutput(s).setMimeType(ContentService.MimeType.JAVASCRIPT); }
function _num(v){ if(v==null) return null; const s=String(v).trim().replace(/[, ]/g,''); if(s==='') return null; const n=Number(s); return isNaN(n)?null:n; }
function _cache(){ return CacheService.getScriptCache(); }

/* ==================== 히스토리 관리 ==================== */
function loadHistory(cid){ if(!cid) return []; try{ const v=_cache().get('chatv4:'+cid); return v?JSON.parse(v):[]; }catch(e){ return []; } }
function saveHistory(cid, hist){ if(!cid) return; try{ _cache().put('chatv4:'+cid, JSON.stringify((Array.isArray(hist)?hist:[]).slice(-20)), CACHE_TTL_SEC); }catch(e){} }
function clearChatHistory(cid){ try{ _cache().put('chatv4:'+cid, '[]', 1); }catch(e){} }

function getWoodTypeName(v){
  const map={ mdf18T:'MDF 18T', pvc18T:'PVC보드 18T+PET', misong18T:'미송집성목 18T', pyeonbaek18T:'편백집성목 18T', mulbau18T:'멀바우 집성목 18T' };
  return map[v] || v;
}

function generateOrderNumber(sheet){
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    const today=Utilities.formatDate(new Date(), Session.getScriptTimeZone(),'yyyyMMdd');
    const last=sheet.getLastRow(); if(last<2) return `${today}-001`;
    const colA=sheet.getRange(2,1,last-1,1).getValues();
    let max=0;
    colA.forEach(r=>{ const v=String(r[0]||''); if(v.startsWith(today)){ const n=parseInt(v.split('-')[1]||'0',10); if(!isNaN(n)&&n>max) max=n; }});
    return `${today}-${String(max+1).padStart(3,'0')}`;
  } finally { lock.releaseLock(); }
}

/* ==================== 단가표 및 가격 계산 ==================== */
function readPriceTableSafe(){
  const ss=SpreadsheetApp.openById(PRICE_SHEET_ID);
  const sh=ss.getSheetByName(PRICE_SHEET_NAME);
  const vals=sh.getDataRange().getDisplayValues();
  const headers=vals[0].map(h=>(h||'').trim());
  const rows=[];
  for(let r=1;r<vals.length;r++){
    const line=vals[r]; if(!line||line.join('').trim()==='') continue;
    const obj={};
    headers.forEach((h,c)=>{
      if(!h) return;
      const key=h.trim(); const raw=(line[c]||'').trim();
      if(key==='area'||key==='배송비'||/18T$/i.test(key)||/단가|가격|fee|cost|price/i.test(key)) obj[key]=_num(raw);
      else obj[key]=raw===''?null:raw;
    });
    if(obj.area!=null) rows.push(obj);
  }
  rows.sort((a,b)=>(a.area||0)-(b.area||0));
  return {headers,rows};
}

function pickRowByArea(rows, area){
  rows.sort((a,b)=>(a.area||0)-(b.area||0));
  for(let i=0;i<rows.length;i++){ if(area<=rows[i].area) return rows[i]; }
  return rows.length?rows[rows.length-1]:null;
}

function calculatePriceFromSheet(order, rid){
  const table=readPriceTableSafe();
  const matKey=String(order.woodTypeValue).trim();
  const area=(Number(order.width)||0)*(Number(order.length)||0);
  const row=pickRowByArea(table.rows, area);
  if(!row) throw new Error('단가표에서 해당 면적을 찾을 수 없습니다.');
  const unitPrice=Number(row[matKey])||0;
  const shippingRaw=Number(row['배송비']||0);
  const qty=Number(order.quantity)||1;
  const shipping=SHIPPING_MODE==='per-unit'?(shippingRaw*qty):shippingRaw;
  return { total:(unitPrice*qty)+shipping, unitPrice, shipping, subtotal:unitPrice*qty };
}

function computeProcessingCost(order){
  const mat=String(order.woodTypeValue||'').toLowerCase();
  const isMdfOrPvc = (mat==='mdf18t'||mat==='pvc18t');
  const qty = Number(order.quantity)||1;
  const len = Number(order.length)||0;
  
  const opts = normalizeOptions(order.options||[]);
  let processingPerUnit = 0;
  const lines=[];

  if(!isMdfOrPvc){
    if(opts.coating_single>0){ const u=(len<=600?5000:len<=1200?10000:15000); processingPerUnit+=u; lines.push(`코팅(단면)`); }
    if(opts.coating_double>0){ const u=(len<=600?10000:len<=1200?20000:30000); processingPerUnit+=u; lines.push(`코팅(양면)`); }
  }

  const FREE = { angled:1, round:1, circlecut:1, squarecut:1, hinge:2 };
  const UNIT = { angled:1000, round:1000, circlecut:3000, squarecut:4000, hinge:1000 };

  ['angled','round','circlecut','squarecut','hinge'].forEach(k=>{
    const count = Math.max(0, Number(opts[k]||0));
    if(count<=0) return;
    const free = FREE[k]||0;
    const paid = Math.max(0, count - free);
    if(paid>0) processingPerUnit += (paid * UNIT[k]);
  });

  return { processingPerUnit, processingTotal: processingPerUnit*qty };
}

function normalizeOptions(arr){
  const sum = { none:0, sanding:0, coating_single:0, coating_double:0, angled:0, round:0, circlecut:0, squarecut:0, hinge:0 };
  if(!Array.isArray(arr)) return sum;
  arr.forEach(o=>{
    if(!o) return;
    let type = (typeof o==='string')?o:String(o.type||o.key||'');
    type = type.toLowerCase().trim();
    const count = Math.max(0, Number((typeof o==='string')?1:o.count||o.qty||1));
    if(type==='none' || /없음/.test(type)) sum.none += count;
    else if(type==='sanding') sum.sanding += count;
    else if(type==='coating' || type==='coating_single' || /단면/.test(type)) sum.coating_single += count;
    else if(type==='coating_double' || /양면/.test(type)) sum.coating_double += count;
    else if(type==='angled' || /사선/.test(type)) sum.angled += count;
    else if(type==='round' || /라운드/.test(type)) sum.round += count;
    else if(type==='circlecut' || /원형/.test(type)) sum.circlecut += count;
    else if(type==='squarecut' || /사각/.test(type)) sum.squarecut += count;
    else if(type==='hinge' || /경첩/.test(type)) sum.hinge += count;
  });
  return sum;
}

/* ==================== AI 채팅 최적화 로직 ==================== */

/* --- 코드 기반 입력 파싱 (GPT 호출 전 사전 처리) --- */
function parseStructuredInput(text){
  const lo = text.toLowerCase().replace(/\s+/g,'');
  const result = { wood: null, width: null, length: null, qty: null };

  // 목재 감지
  const woodMap = {
    'mdf': 'mdf18T', 'MDF': 'mdf18T',
    'pvc': 'pvc18T', 'PVC': 'pvc18T', '피브이씨': 'pvc18T',
    '미송': 'misong18T',
    '편백': 'pyeonbaek18T',
    '멀바우': 'mulbau18T'
  };
  for(const [keyword, key] of Object.entries(woodMap)){
    if(lo.includes(keyword.toLowerCase())) { result.wood = key; break; }
  }

  // 사이즈 감지: NxM, N*M, NXM, N×M
  const sizeMatch = text.match(/(\d{2,4})\s*[xX×\*]\s*(\d{2,4})/);
  if(sizeMatch){
    result.width = parseInt(sizeMatch[1]);
    result.length = parseInt(sizeMatch[2]);
  }

  // 수량 감지: N개, N장, 수량N, 수량 N
  const qtyMatch = text.match(/(\d+)\s*[개장]/) || text.match(/수량\s*(\d+)/);
  if(qtyMatch) result.qty = parseInt(qtyMatch[1]);

  return result;
}

function buildStructuredResponse(parsed, cid){
  const w = parsed.width, l = parsed.length;

  // 사이즈 검증
  if(w !== null && l !== null){
    if(w > 600) return { result:'ok', reply:'폭은 <b>최대 600mm</b>까지 가능합니다. 수정해 주세요.', action:'need_info' };
    if(l > 1800) return { result:'ok', reply:'길이는 <b>최대 1800mm</b>까지 가능합니다. 수정해 주세요.', action:'need_info' };
    if(w < 10 || l < 10) return { result:'ok', reply:'최소 사이즈는 <b>10mm</b>입니다. 수정해 주세요.', action:'need_info' };
  }

  const hasWood = parsed.wood !== null;
  const hasSize = parsed.width !== null && parsed.length !== null;
  const hasQty  = parsed.qty !== null;

  // 모두 있으면 → show_processing (GPT 안 거침)
  if(hasWood && hasSize && hasQty){
    const woodNames = { mdf18T:'MDF', pvc18T:'PVC보드', misong18T:'미송집성목', pyeonbaek18T:'편백집성목', mulbau18T:'멀바우' };
    const name = woodNames[parsed.wood] || parsed.wood;
    return {
      result:'ok',
      reply: `<b>${name}</b> ${w}×${l}mm <b>${parsed.qty}장</b>으로 진행합니다.<br>추가가공 옵션을 선택해 주세요.`,
      action: 'show_processing',
      data: { woodType: parsed.wood, width: w, length: l, qty: parsed.qty }
    };
  }

  // 목재+사이즈는 있는데 수량 없음
  if(hasWood && hasSize && !hasQty){
    return { result:'ok', reply: `사이즈 <b>${w}×${l}mm</b> 확인했습니다. <b>수량</b>은 몇 장으로 하시겠어요?`, action:'need_info' };
  }

  // 목재만 있고 사이즈 없음
  if(hasWood && !hasSize){
    return { result:'ok', reply: `목재 선택 확인했습니다. <b>사이즈</b>(폭×길이 mm)를 알려주세요.`, action:'need_info' };
  }

  // 구조화 데이터 없음 → null 반환 (GPT에게 위임)
  return null;
}

function buildChatSystemPrompt(){
  return `당신은 "아이린가구" 목재 재단 상담 AI입니다. 한국어로 친절히 답하세요.

[목재 5종 - 두께 18T 고정]
- mdf18T: MDF. 가성비. 습기취약. 샌딩/코팅 불가.
- pvc18T: PVC보드. 완전방수. 욕실/주방. 샌딩/코팅 불가.
- misong18T: 미송집성목. DIY표준. 초보 추천.
- pyeonbaek18T: 편백집성목. 항균/향기. 아이가구 추천.
- mulbau18T: 멀바우. 매우 단단. 고급 가구.

[추천 가이드]
- 아이가구 → 편백 or 미송
- 욕실/주방 → PVC보드
- 고급/단단한 → 멀바우

[응답 형식 - 반드시 JSON만 반환]
{ "reply": "설명(HTML OK)", "action": "chat|show_woods|need_info" }

[action]
- "chat": 일반 대화, 설명, 답변
- "show_woods": 목재 추천 시 목재카드 표시
- "need_info": 추가 정보 질문

참고: 목재+사이즈+수량 파싱은 시스템이 자동 처리합니다. 당신은 추천/상담/질문 답변에만 집중하세요.`;
}

function handleChatRequest(message, rid, cid){
  // 1단계: 코드 기반 파싱 시도
  const parsed = parseStructuredInput(message);
  const codeResult = buildStructuredResponse(parsed, cid);

  if(codeResult){
    // 코드가 처리한 경우 → 히스토리에 기록하고 바로 반환
    let history = loadHistory(cid);
    history.push({ role:'user', content: message });
    history.push({ role:'assistant', content: JSON.stringify(codeResult) });
    saveHistory(cid, history);
    return codeResult;
  }

  // 2단계: 구조화 데이터 없음 → GPT에게 위임
  const apiKey = getOpenAiApiKey();
  let history = loadHistory(cid);
  const messages = [{ role: 'system', content: buildChatSystemPrompt() }];
  history.forEach(h => messages.push(h));
  messages.push({ role: 'user', content: message });

  const res = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', {
    method: 'post',
    contentType: 'application/json',
    headers: { 'Authorization': 'Bearer ' + apiKey },
    payload: JSON.stringify({ model: 'gpt-4o-mini', temperature: 0.3, response_format: { type: 'json_object' }, messages }),
    muteHttpExceptions: true
  });

  const json = JSON.parse(res.getContentText());
  const assistantMsg = json.choices[0].message.content;
  const result = JSON.parse(assistantMsg);

  history.push({ role: 'user', content: message });
  history.push({ role: 'assistant', content: assistantMsg });
  saveHistory(cid, history);

  return { result: 'ok', ...result };
}

/* ==================== 주문 저장 (기존 doPostMessaging 등 하위 호환성 유지) ==================== */
function doPostMessaging(data) {
  const rid = Utilities.getUuid().slice(0,8);
  try {
    const payload = (typeof data === 'string') ? JSON.parse(data) : data;
    const customer = payload.customer || {};
    const orders   = payload.orders || [];
    if (!orders.length) return { result:'error', message:'주문 항목이 없습니다.' };

    const ss = SpreadsheetApp.openById(ORDER_SHEET_ID);
    let sh = ss.getSheetByName(ORDER_SHEET_NAME);
    if (!sh) {
      sh = ss.insertSheet(ORDER_SHEET_NAME);
      sh.appendRow(['주문번호','날짜','성함','전화번호','이메일주소','품명','폭(mm)','길이(mm)','수량','가공상세','합계']);
    }

    const orderNumber = generateOrderNumber(sh);
    const ts = new Date();
    let totalAmount = 0;

    orders.forEach(order=>{
      let rowData=null;
      totalAmount += Number(order.estimate)||0;

      if (order.type === 'discount') {
        rowData = [orderNumber, ts, customer.name||'', customer.phone||'', customer.email||'', '[이벤트 할인]', '-', '-', '-', '', (Number(order.estimate)||0)];
      } else if (order.type === 'accessory') {
        rowData = [orderNumber, ts, customer.name||'', customer.phone||'', customer.email||'', '[부자재] '+(order.name||''), '-', '-', (order.quantity||''), '-', (Number(order.estimate)||0)];
      } else {
        let processingDetails = '가공 없음';
        if (!order.noOption && order.detailText && Object.keys(order.detailText).length>0) {
          const summaryArray=[];
          Object.values(order.detailText).forEach(detail=>{
            if (detail && Array.isArray(detail.summary)) detail.summary.forEach(line=>summaryArray.push(String(line).replace(/<[^>]*>/g,'')));
            else if (detail && typeof detail.summary==='string') summaryArray.push(detail.summary);
          });
          if (summaryArray.length>0) processingDetails = summaryArray.join(' | ');
        }
        const itemName = getWoodTypeName(order.woodTypeValue) || order.woodTypeValue || '[기타]';
        rowData = [orderNumber, ts, (customer.name||'') , customer.phone||'', customer.email||'', itemName, order.width||'-', order.length||'-', order.quantity||'-', processingDetails, order.estimate||0];
      }
      if(rowData) sh.appendRow(rowData);
    });

    if (Array.isArray(payload.shippingItems)) {
      payload.shippingItems.forEach(item=>{
        const shipTotal = Number(item.cost||0) * Number(item.count||0);
        totalAmount += shipTotal;
        sh.appendRow([orderNumber, ts, customer.name||'', customer.phone||'', customer.email||'', '예상 배송비', '-', '-', item.count||0, (item.sizeCategory||''), shipTotal]);
      });
    }

    SpreadsheetApp.flush();
    try { sendOrderNotifications(customer, orderNumber, totalAmount); } catch(e){}
    return { result: 'success', orderNo: orderNumber, totalAmount, rid };
  } catch(err) { return { result: 'error', message: err.toString(), rid }; }
}

function sendOrderNotifications(customer, orderNo, total) {
  const vars = { '#{고객명}': customer.name || '', '#{주문번호}': orderNo, '#{합계}': Number(total||0).toLocaleString() };
  try { sendAlimtalk(customer.phone, vars); } catch(e){}
  if(customer.email) try { sendOrderConfirmationEmail(customer.email, customer.name, orderNo, total); } catch(e){}
}

/* ==================== HTTP 핸들러 (doGet, doPost) ==================== */
function doGet(e) {
  const cb = e.parameter.callback;
  const phone = e.parameter.phone;
  const orderNo = e.parameter.orderNo;
  if (phone && orderNo) {
    const res = findOrdersByPhoneAndOrderNo(phone, orderNo);
    return jsonpOutput(res, cb);
  }
  return jsonpOutput({ result: 'error', message: '파라미터 부족' }, cb);
}

function doPost(e) {
  const rid = Utilities.getUuid().slice(0, 8);
  const p = e.parameter || {};
  
  // 상황 1. 기존 current-woodcut.html 등의 일반 폼 전송 (data 파라미터)
  if (p.data) {
    return jsonOut(doPostMessaging(p.data));
  }

  // 상황 2. 신규 채팅 woodcut.html 등의 JSON 전송
  let bodyText = (e.postData && e.postData.contents) ? e.postData.contents.toString() : '';
  if (bodyText.startsWith('{')) {
    const body = JSON.parse(bodyText);
    const cid = body.cid || 'anon';
    if (body.type === 'chat') {
      if (body.message === 'reset') { clearChatHistory(cid); return jsonOut({ result: 'ok', reply: '대화가 초기화되었습니다.' }); }
      return jsonOut(handleChatRequest(body.message, rid, cid));
    }
    if (body.type === 'order') {
      return jsonOut(doPostMessaging(body.data));
    }
  }

  // 상황 3. 기타 텍스트 전송 (cid: 포함 가능)
  if (bodyText) {
    const cidMatch = bodyText.match(/\[cid:([^\]]+)\]/);
    let cid = cidMatch ? cidMatch[1] : 'anon';
    let cleanMsg = bodyText.replace(/\[cid:[^\]]+\]/, '').trim();
    return jsonOut(handleChatRequest(cleanMsg, rid, cid));
  }

  return jsonOut({ result: 'error', message: '처리할 수 없는 요청입니다.' });
}

/* ==================== 주문 조회 및 알림 (나머지 원복) ==================== */
function findOrdersByPhoneAndOrderNo(phone, orderNo) {
  const ss = SpreadsheetApp.openById(ORDER_SHEET_ID);
  const sh = ss.getSheetByName(ORDER_SHEET_NAME);
  const vals = sh.getDataRange().getValues();
  const headers = vals[0];
  const out = [];
  const cleanPhone = String(phone).replace(/-/g, '');
  for (let r = 1; r < vals.length; r++) {
    if (String(vals[r][0]) === String(orderNo) && String(vals[r][3]).replace(/-/g, '') === cleanPhone) {
      const obj = {};
      headers.forEach((h, i) => obj[h] = vals[r][i]);
      out.push(obj);
    }
  }
  return { result: 'success', data: out };
}

function jsonpOutput(obj, cb) {
  const json = JSON.stringify(obj);
  return cb ? jsOut(`${cb}(${json});`) : jsonOut(obj);
}

function sendAlimtalk(receiverPhone, variables) {
  const apiUrl = 'https://api.solapi.com/messages/v4/send';
  const now = new Date().toISOString();
  const salt = Utilities.getUuid();
  let sig = Utilities.computeHmacSha256Signature(now + salt, SOLAPI_API_SECRET);
  sig = sig.map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join('');
  const payload = { message: { to: String(receiverPhone).replace(/-/g,''), kakaoOptions: { pfId: KAKAO_PF_ID, templateId: TEMPLATE_ID, variables } } };
  const options = { method: 'post', contentType: 'application/json', headers: { 'Authorization': `HMAC-SHA256 ApiKey=${SOLAPI_API_KEY}, Date=${now}, salt=${salt}, signature=${sig}` }, payload: JSON.stringify(payload), muteHttpExceptions: true };
  UrlFetchApp.fetch(apiUrl, options);
}

function sendOrderConfirmationEmail(email, name, orderNo, total) {
  const subject = `[아이린가구] ${name}님의 견적(${orderNo})이 도착했습니다.`;
  const body = `최종 견적: ${Number(total).toLocaleString()}원\n주문번호: ${orderNo}`;
  MailApp.sendEmail(email, subject, body);
}
